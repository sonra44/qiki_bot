##  Этап 3 — FSM: изоляция доступа + валидация состояния

###  Цель:

Полностью запретить прямой доступ к `fsm_state.json` из любых других частей системы. Всё управление FSM должно происходить **только через `fsm_client.py`**.

###  Что нужно реализовать:

#### 1.  В `fsm_client.py`:

* [ ] Добавить метод `get_state()` — безопасное чтение FSM-состояния
* [ ] Добавить метод `set_state(state_obj, *, trigger=None, source=None)`:

  * Проверка валидности `state_obj` по схемe (см. пункт 2)
  * Логгирование: в `fsm_logger.log` (`from → to`, trigger, source)
  * Обновление `fsm_state.json`

#### 2.  Валидация FSM-структуры:

* [ ] Создать встроенную схему FSM (внутри `fsm_client.py` или `fsm_schema.json`)
* [ ] Перед записью — валидация структуры: наличие всех нужных полей (`mode`, `task`, `status`, и т.д.)
* [ ] При ошибке — запись в `logs/fsm_errors.log`

#### 3.  Удалить прямые обращения:

* [ ] Найти и заменить **все вызовы `open('fsm_state.json')`** на `FSMClient.get_state()` / `FSMClient.set_state(...)`
* [ ] Прямой доступ запрещён

---

##  Команда для Gemini CLI:

```
Приступи к архитектурному этапу 3:

 Изолируй доступ к FSM-состоянию:
1. В `fsm_client.py` добавь методы get_state() и set_state(state_obj, trigger, source)
2. Реализуй встроенную валидацию состояния FSM (поля, структура)
3. Все обращения к fsm_state.json должны идти только через эти методы
4. Прямой доступ к файлу — удалить
5. Логгирование переходов FSM — в fsm_logger.log
6. Ошибки структуры — в fsm_errors.log

По завершении — сообщи, какие модули были изменены и готов ли компонент к проверке.
```

---

Готов вставлять его и запускать.
Как только Gemini CLI завершит — двигаемся к **этапу 4 (agent\_comm.py и TTL)**.